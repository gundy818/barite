#
#
require "../exception"
require "crest"
require "digest/sha1"
require "json"


module Barite
  module B2

    # Represents a file in a specific bucket on Backblaze.
    # This is normally generated by calling B2#file.
    # Once you have this object you can upload and download the file using File#upload,
    # File#download.
    class File
      # The linked B2 object.
      getter b2

      # The bucket containing this file.
      getter bucket_name

      # The filename as stored in the bucket.
      getter file_name

      @bucket_id : String?
      @upload_token : String?
      @upload_url : String?

      # Create a reference for the named file in the named bucket.
      # Note that the @max_versions parameter is not yet used. Every time you
      # upload the same file name you will create a new version of the same file.
      # Note that B2 filenames are strings but they can include a path, such as "abc/def".
      # Some tools will interpret this as a file called 'def' in a folder 'abc', and it is
      # OK to think of it like this, but the 'abc/' is really just part of the filename.
      def initialize(@b2 : Barite::B2::API, @bucket_name : String, @file_name : String)
      end

      # Retrieve the bucket ID.
      # Caches the result on first use.
      def bucket_id() : String
        @bucket_id ||= @b2.get_bucket_id(@bucket_name)

        return @bucket_id.as(String)
      end

      # Downloads the referenced file to a local file.
      # local_file_path is the pull path, including filename.
      # If the stored file has a modification time stored in a
      # "X-Bz-Info-src_last_modified_millis" header, the timestamp will be set on the file
      # after a successful download.
      def download(local_file_path : String)
        # this needs to be percent encoded
        x_bz_file_name = @file_name

        response = Crest.get(
          "#{@b2.api_url()}/file/#{@bucket_name}/#{x_bz_file_name}",
          headers: {
            "Authorization" => @b2.api_token(),
          },
        )

        File.write(local_file_path, response.body)

        # set the modified time on the file if the header is present
        begin
          modified_time = Time.unix_ms(response.headers["X-Bz-Info-src_last_modified_millis"].as(String).to_i64)
          File.utime(modified_time, modified_time, local_file_path)
        rescue KeyError
          # doesnt matter, dont set the time
        end
      end

      # Retrieve the upload token for the bucket.
      # Caches the result on first use.
      # Upload tokens seem to be re-usable, so you only need to get it once.
      def upload_token() : String
        @upload_url, @upload_token = @b2.get_upload_url(bucket_id()) if @upload_token.nil?

        return @upload_token.as(String)
      end

      # Retrieve the upload URL.
      # Caches the result on first use.
      def upload_url() : String
        @upload_url, @upload_token = @b2.get_upload_url(bucket_id()) if @upload_url.nil?

        return @upload_url.as(String)
      end

      # Upload the file from the local file path.
      # The modification time from the local file is set in the
      # "X-Bz-Info-src_last_modified_millis" header, so it will be returned when the file
      # is downloaded.
      def upload(local_file_path : String)
        # this needs to be percent encoded
        x_bz_file_name = file_name
        begin
          content = File.read(local_file_path)
        rescue ex : File::NotFoundError
          raise Barite::NotFoundException.new("Error opening file: #{local_file_path}")
        end

        content_sha = Digest::SHA1.hexdigest(content)
        content_length = File.size(local_file_path)
        modified_time = File.info(local_file_path).modification_time.to_unix_ms

        response = Crest.post(
          upload_url(),
          headers: {
            "Authorization" => upload_token,
            "Content-Length" => content_length.to_s,
            "Content-Type" => "text/plain",
            "X-Bz-Content-Sha1" => content_sha,
            "X-Bz-File-Name" => x_bz_file_name,
            "X-Bz-Info-src_last_modified_millis" => modified_time.to_s,
            "X-Bz-Server-Side-Encryption" => "AES256"
          },
          form: content
        )

        data = JSON.parse(response.body)
        file_id = data["fileId"].to_s

        return file_id
      end
    end
  end
end

